---
title: 前端技术理论
date: 2020-04-15
sidebar: "auto"
categories:
  - 前端
tags:
  - 技术笔记
note: 常见前端技术问题
---

::: tip
常见前端技术问题
:::

<!-- more -->

### 技术问题

1. 关于html状态码的了解？常用的状态码有哪些？？
2. 兼容性问题？怎么处理兼容？
3. 什么是axios？怎么使用？支持跨域？！
4. vue中的MVVM模式？
5. react和vue有哪些不同 说说你对这两个框架的看法
6. 关于element-ui有哪些了解?
7. bootstrap框架中的栅格系统的本质是什么？以及bootstrap框架的优缺点？
8. 对于ES6的了解？
9. 关于node.js？
10. 介绍一下闭包和闭包常用场景？
11. H5C3特性？
12. 关于this指向？
13. vuex?
14. 作用域及作用域链？
15. 数据类型？
16. 深拷贝和浅拷贝？
17. 跨域？
18. 构造函数？
19. 行内元素和块级元素？
20. 关于 v-if 和 v-show？
21. 项目开发流程
22. 代码重构
23. 虚拟dom
24. ajax
25. 小程序
26. less和sass
27. js
28. jq
29. 单页面与多页面

### 问题回答

##### 1 状态码

> 这些状态码被分为五大类： 
> 100-199 用于指定客户端应响应的某些动作。 （**临时响应**）
> 200-299 用于表示请求成功。 
> 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。(影响seo，不建议使用**重定向**) 
> 400-499 用于指出客户端的错误。 （**请求错误**） 
> 500-599 用于指出服务器错误。

> 一些常见的状态码为： 
> 200 - 服务器成功返回网页 
> 404 - 请求失败，请求的网页不存在 
> 503 - 服务不可用  

##### 2 兼容 -- 渐进增强，优雅降级

1 由于不同浏览器对代码的解析不同，而产生的在页面上显示的效果不同。

2 处理兼容

* 图片默认有间隙：给img标签添加display：block；
* ie绑定事件-attachEvent,非ie可用addEventListener；
* 按钮的默认大小不一：用a标签来模拟按钮，添加样式；
* 上下margin的重叠问题（塌陷）：只设置其中一个值；
* 设置较小高度的容器（小于10px），在IE6下不识别小于10px的高度：给容器添加overflow：hidden；

**渐进增强，优雅降级**：

**渐进增强**（progressive enhancement）：针对低版本浏览器进行构建页面，保证最**基本的功能**，然后再针对高级浏览器进行效果、交互等改进和**追加功能**达到更好的用户体验

**优雅降级（Graceful Degradation）**：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

**区别**：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要

##### 3 axios

1. axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。| 是请求后台资源的模块
2. 常用的请求方式有get（请求数据） | delete(删除数据) | post（添加数据）| put（修改数据）
3. 拦截器：需要统一处理http请求和响应时
4. 可以支持跨域，但需要进行配置

##### 4 MVVM模式与MVC模式

MVC：m是model（数据|返回的json）；v是view（界面）；c是controller（显示逻辑）；就是在数据和渲染模块中间加一个控制层

MVVM：支持双向绑定，意思就是当M层数据进行修改时，VM层会监测到变化，并且通知V层进行相应的修改，反之修改V层则会通知M层数据进行修改，以此也实现了视图与数据变量的相互解耦；

**原理**？？？

1. **响应式：vue如何监听data的属性变化**
   * 通过Object.defineProperty将data里的每一个属性的访问与修改都变成了一个函数，在函数get和set中我们即可监听到data的属性发生了改变。
2. **模板解析：vue的模板是如何被解析的**
   * render函数中的with函数。with函数将某个对象添加到作用域链的顶部，如果在 statement中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。
3. **渲染：vue模板是如何被渲染成HTML的**

##### 5  react和vue

1. 都用了virtual dom的方式, 性能都很好
2. ui上都是组件化的写法，开发效率很高
3. vue是双向数据绑定，react是单项数据绑定，当工程规模比较大时双向数据绑定会很难维护
4. vue适合不会持续的 、小型的web应用，使用vue.js能带来短期内较高的开发效率. 否则采用react
5. vue缺点：存在兼容性问题（兼容到ie9）；不利于SEO，解决：使用nuxtjs做服务端渲染（基于vue的）

##### 6 element-ui

是Vue的ui框架（组件库）

常用的组件有：botton | Form 表单 | Breadcrumb 面包屑 | carousel 走马灯（轮播图）| Pagination 分页

##### 7 bootstrap

缺点：对ie678的兼容性可能不太好，而且bootstrap是依赖于jQuery，代码的体积大，会影响网页的加载速度，不适合移动端

##### 8 ES6

1. let 和 const, let是定义变量，块级作用域。const是代表常量，而es5的var没有块级作用域
   1. 块级作用域能避免：内层变量覆盖外层变量；用来计数的循环变量泄露为全局变量。 （var=i...）
2. 箭头函数：引入箭头函数有两个方面的作用：更简短的函数并且不绑定this
3. 模块化：export 和 import；import 导入模块、export 导出模块
4. Promise 做异步请求：.then成功 .catch失败 .race( [p1, p2, p3] )返回最快获取到的结果

##### 9 关于node.js

优点：基于事件驱动和无阻塞的，非常适合处理并发请求

缺点：单线程，要考虑的东西比较多，一旦这个线程死了，就全站死了

##### 10 闭包

* 闭包是指有权访问另一个函数作用域中的变量的函数. 创建闭包常见方式,就是在一个函数内部创建另一个函数.（ **闭包就是能够读取其他函数内部变量的函数。**）
* 本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
* 解决了：受JavaScript链式作用域结构的影响，父级变量中无法访问到子级的变量值
* 应用场景：闭包有用之处在于它可以将一些数据和操作它的函数关联起来。只用一个方法操作一个对象时，可以使用闭包。
* 优点：1 方便调用上下文的局部变量。2 加强封装性，可以达到对变量的保护作用。
* 缺点：函数中的变量都被保存在内存中，内存消耗很大

##### 11 H5C3

h5 新标签： header、footer、nav、section这些语义化更好的内容标签

新的API： 

* 地理定位
* 拖拽释放
* 本地存储  1 postMessage 解决跨域问题 2 localStorage长期存储，浏览器关闭后数据不丢失；sessionStorage 临时存储，不共享，关闭页面数据丢失；

c3：

* 选择器：属性选择器 （E[arrt]）,伪类选择器（nth-of-type(n)）
* 颜色rgba：背景透明，字体不会透明
* 盒模型：box-sizing:content-box(标准模式盒模型)|border-box(怪异|内减模式盒模型)
* 渐变、背景、过度、动画、伸缩布局、媒体查询
* background-origin|clip: context-box,配合padding值增大响应区

##### 12 this

**this指向**

this的指向在函数定义的时候是确定不了的，只有**函数执行**的时候才能确定this到底指向谁，实际上this的最终指向的是那个**调用它的对象**

* 被上一级的对象所调用，那么this指向的就是上一级的对象
* 没有被上一级的对象所调用，那么this指向的就是window
* **当this遇到return**：如果返回值是一个对象（除了null），那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 

**改变this指向**

* **new**关键字改变this指向（用了new关键字就等同于复制了一份）
* **call()**：第一个参数表示this指向的那个对象。其他的参数是一个列表
* **apply()**：第一个参数表示this指向的那个对象。第二个参数必须是一个数组
* **bind()**：第一个参数绑定this，从第二个参数起，表示**原始函数**的参数；返回的是一个修改过后的**函数**。（f.bind(obj)，实际上可以理解为obj.f()，此时函数**未调用**）

 call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别

call和apply**应用场景**：

* 调用函数（null或者undefined，那么函数中this不改变）
* 改变所调用函数的内部this指向
* 借用别的对象的方法
* 转化类数组（伪数组？）

##### 13 vuex

是一个针对vue开发的**状态管理模式**

**结构**

Vue components 代表组件，展示数据

State 保存数据的对象

mutations：一个对象，唯一作用-更改State里面的数据

Actions : 一个对象，保存的是触发mutations的函数，让mutations去修改State里面的值，（能通过请求触发）

getters：State的计算属性；监听State数据变化？？

**使用场景**：涉及到非父子组件数据交互，相当于数据的中转站

**缺点**：1 没有持久化存储的手段，每次刷新都会重置所有的数据（使用localStorage解决vuex在页面刷新后数据被清除的问题）；2 对于小型单页应用，使用 Vuex 可能是繁琐冗余的

##### 14 作用域及作用域链

**作用域**：js中全局变量和局部变量的作用域，局部变量的优先级要高于同名的全局变量

​		（当声明一个全局变量的时候，实际上是定义了全局对象window的一个属性。）

**作用域链**：

作用域链是一个对象列表，用来检索各个变量对象中的变量和函数，保证执行环境有权访问哪些变量和函数

1 执行环境；

2 解析器处理代码时的两个阶段：预解析（作用域链和this确定）、执行阶段；

代码解析执行后，会将Global对象作为变量对象，当解析器进入函数执行环境时，则会创建一个活动对象作为变量对象，活动对象还会创建一个Arguments对象，arguments对象是一个参数集合，用来保存参数，这就是我们写函数时可以使用arguments[0]等来使用参数的原因。

##### 15 数据类型

**基本数据类型**：number,string,boolean,null,undefined五类。

**引用数据类型**：(Object类)有常规键值对的无序**对象**{a:1}，**数组**[1,2,3]，以及**函数**等。

**ES6新增数据类型**：Symbol（用来定义对象的唯一属性名）

##### 16 深拷贝和浅拷贝

**浅拷贝**-->只会复制目标对象的第一层属性

**深拷贝**-->递归拷贝目标对象的所有属性

**区别**：简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。

##### 17 跨域

原因：由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。（存在跨域的情况：跨域请求资源的方法）

解决：

**前后端配合处理跨域**：**CORS** （一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作）

**前端处理跨域**：

jsonp、**反代**（反向代理、Nginx）、postMessage()、fetch、header（服务器那边设置)、

使用**jsonp**

1. 动态添加一个script标签，里面的src属性自带跨域；浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。获取的数据一般为json格式。）
2. ajax里面的dataType属性值要为 “ jsonp ”,jsonpCallback指定回调函数

使用**postMessage**解决跨域

```js
// postMessage解决跨域
// 参数：1.data:要传递的数据，部分浏览器只能处理字符串参数；2.origin：字符串参数，指明目标窗口的源。参数设置为"*"，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。
window.onload=function(){
    window.frames[0].postMessage('getcolor','http://lslib.com');
}
```

**反向代理**：在config文件夹里面的index.js的proxyTable属性

![配置跨域](F:\文档文件\笔记截图\配置跨域.png)

##### 18 构造函数

如果在一个函数前面加上new关键字来调用，这个函数就可以称为此对象的构造函数。

##### 19 行内元素和块级元素

块级元素：块级大多为结构性标记

* div、h1~h6、hr（水平线）、p、ul（非排序表单）、ol（排序表单）、dl（列表）、table（表格）、form （表单）、button 

行内元素：行内大多为描述性标记

* span、a、br（换行）、strong|b（字体加粗）、em|i（斜体）、ins|u（下划线）、del|s（删除线）、label （表格标签）、textarea （多行文本输入框 ）、big（大号字体加粗）

行内块元素：在行内一块一块的排布

* img、input、select、textarea、button、(表单元素)；

##### 20  v-if 和 v-show

**共同点**：v-if 和 v-show 都能用于控制元素的显示与隐藏 他们俩的后面直接跟一个布尔值，如果为true就显示，为false就隐藏

**区别**：v-if 通过直接操作dom来控制元素的显隐；而v-show 通过display:none 来控制元素的显隐

**使用场景区别**：

1. 涉及到频繁切换大量元素的显示与隐藏的时候，用v-show合适
2. 涉及到异步数据渲染时，用v-if合适(能更新内部组件的视图)

##### 21 项目开发流程

**项目需求分析**：

这个环节是由项目经理完成，项目经理首先和客户进行交流，了解客户的需求，然后分析项目的可行性，如果项目可以被实现，项目经理写出项目需求文档交给设计师完成后续的开发。

**页面设计**：

这个环节主要是UI设计师参与，UI设计师根据产品需求分析文档，对产品的整体美术风格、交互设计、界面结构、操作流程等做出设计。负责项目中各种交互界面、图标、LOGO、按钮等相关元素的设计与制作。

**编码**：

这个部分由程序员来实现。（程序员分为WEB前端开发工程师和后台开发工程师。前端开发人员主要做我们可以在网页上看的见的页面，后台就做一些我们看不见的**管理系统**以及**功能的实现**。）程序员根据UI设计师的设计，用编码来完成整个项目的各个功能。

**测试**：

这部分由程序测试员来完成。程序测试员主要就是测试寻找程序还存在的bug，一般来说刚编码完成的程序都是存在问题的，就需要测试人员反复不断的测试并将存在问题的测试结果交给编码人员进行bug的修复。等到几乎所有bug修复完成，这个项目差不多就可以上线了。

**维护**：

程序的维护是整个项目的最后一个阶段，但也是耗时最多，成本最高的一个阶段。程序的维护包括**程序上线后后续bug的修复**和**程序版本的更新**。

##### 22 代码重构

**概念**：重构指的是在**不改变代码外部行为**的情况下进行源代码修改。 
**目的**：重构的目的主要是提高代码的可维护性、可读性和性能。 
（重构之前需要**考虑**的是重构后如何才能保证外部行为不改变。）

**重构的过程**：

1、**删除无用代码，精简代码**

修改的过程需要注意，不停地查看函数和变量在上下文的调用关系，以免删错代码。

2、**前端代码规范化**

- 将css代码放到独立的文件中
- 调整代码的层次缩进格式，不同层级按照4个空格缩进
- 更改标准已不推荐的标签，如`<center>、<b>`，改为由css控制
- 统一命名规则
- 缩小变量作用域，尽量将全局变量变为局部变量

3、**整理基础类库** 
对于引入的多个框架，相同的实现可能使用的是不同类库中的功能，如DOM选择、AJAX请求等。需要统一基础方法的使用。

4、**前端代码模块化**

按照模块归类css代码，放到模块对应的单独css文件中
按照模块分离JavaScript代码，按照模块定义不同的命名空间
将JavaScript代码中的通用方法归类到独立的共通文件中，同时引入面向对象的思想重构JavaScript代码，进一步明确公有接口和私有接口
提高页面加载性能 
1）将不影响首页展示的JavaScript文件延迟到页面加载后加载 
2）删除页面中初始隐藏的区域，通过JavaScript按需动态生成 
3）页面中的图片延迟加载 
4）css文件放到JavaScript文件前面 
5）静态文件设置缓存 
6）使用css sprite，合并首页背景图 
7）合并和压缩发布后的css和JavaScript代码文件

---------------------

##### 23 虚拟dom

Virual DOM是用JS对象记录一个dom节点的副本，当dom发生更改时候，先用
虚拟dom进行diff（比较），算出最小差异，然后再修改真实dom。

**应用场景**

1. 大量的dom修改
2. 适用于大多数单页面应用（dom节点多，小却频繁的更新会拖慢页面速度）

**缺点**

* 小量的单一的dom修改使用成本反而更高
* 内存占用增大
* 代码更多，体积更大

##### 24 ajax

**常用属性**

url（请求地址）、type（请求类型）、data（发送的数据）、dataType（返回数据类型）、async（默认true 异步）、timeout（请求超时时间）、beforeSend（发送请求前回调）、complete（请求完成后）、success（请求成功后）、error（请求失败时）、jsonp（值会替代callback键）、jsonpCallback（替代callback的值）

**原生代码**

~~~js
//1.创建ajax对象
var oAjax = new XMLHttpRequest();
//2.连接到服务器
	//open(方法、文件名、异步传输）
oAjax.open("GET","a.txt?t='+new Date().getTime()",true);
//3.发送请求（告诉服务器我要什么文件）
oAjax.send();
//4.接收返回值
xmlhttp.onreadystatechange = function () {
    if (xmlhttp.readyState == 4) {//响应内容解析完成，可以在客户端调用。
        document.getElementById("user1").innerHTML = "数据正在加载...";
        if (xmlhttp.status == 200) {//判断是否成功
            document.write(xmlhttp.responseText);
        }
    }
}
~~~

##### 25小程序

**生命周期**：一般小程序周期函数在前，页面周期函数触发在后；

小程序

* onLaunch监听小程序初始化
* onShow监听小程序显示
* onLaunch监听小程序隐藏

页面

* onLoad监听页面加载
* onReady监听页面初次渲染完成
* onShow监听页面显示
* onHide监听页面隐藏
* onUnload监听页面卸载

**优点**

1. 无需下载，通过搜索和扫一扫就可以打开
2. 打开速度快，良好的用户体验
3. 开发成本比APP低
4. 良好的安全保障（微信审查）

**缺点**

1. 限制较多：页面大小不能超过1M，不能打开超过5个层级的页面
2. 样式单一：小程序部分组件是成型的，样式不可以修改，如 幻灯片、导航；
3. 推广面窄：不能分享朋友圈，只能通过 分享给朋友、附近小程序推广；
4. 依托微信，无法开发后台管理功能

处理异步请求：promise、async/await、

##### 26 less和sass

**共同点**

> **混合（Mixins）：**class中的class;
>
> **参数混合（Parametric）：**可以像函数一样传递参数的class;
>
> **嵌套规则（Nested Rules）：**class中嵌套class，从而减少重复的代码；
>
> **运算（Operations）：**css中的数学计算；
>
> **颜色功能（Color function）：**可以编辑你的颜色；
>
> **命名空间（Namespaces）：**样式分组，从而方便被调用；
>
> **作用域（Scope）：**局部修改样式；
>
> **JavaScript表达式(Javascript evaluation)：**在CSS样式中使用Javascript表达式赋值。

**不同点**

> **运行环境**
>
> less是基于JavaScript运行（需要额外时间处理，解决：开发环节使用，开发完成，就复制粘贴less输出的到一个压缩器，然后到一个单独的CSS文件来替代less文件。|使用LESS APP来编译和压缩less文件。）,所以less是在客户端处理。
>
> sass是基于Ruby的，是在服务器端处理的。 
>
> **作用域**
>
> less:在#header中重新定义了color变量，变量的值将会是不同的而且只会在该选择器中有效。它之前或者之后的所有地方，如果没有被重新定义，都会保持那个原始的值。
>
> sass:变量的值改变后，代码中，此处之后的该变量的值，将会被重写 
>
> **输出格式**
>
> 然而LESS并没有输出设置，而Sass提供4中输出选项：nested, compact, compressed 和 expanded。
>
> **适用场景**
>
> sass：Ruby或HAML 
>
> less：PHP和Javascript （便于引入和能够使用JavaScript表达式以及文档属性。 ）

##### 27 js

概念：js是弱类型语言（不用考虑声明的变量类型，靠后面的值决定）

js内嵌：放在后面-加快页面显示，不用加window.onload函数（避免获取的元素还未加载）

##### 28 jq

优点：插件的使用更自由

对象：获取到的是一个包装好的对象，以数组的形式；而原生的对象只有标签

##### 29 单页面与多页面

​			单（SPA）与	 多（MPA）区别 ---（详情见笔记截图！）

单页面相对来说：缺点是不利于SEO（搜索引擎优化），但可利用SSR（服务器端渲染）优化

