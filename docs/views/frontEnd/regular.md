---
title: 前端正则
date: 2020-04-15
sidebar: "auto"
categories:
  - 前端
tags:
  - 技术
  - 扩展
note: 前端常用正则
---

::: tip
前端常用正则
:::

<!-- more -->

# 前端正则

简介：正则表达式是对字符串操作的一种逻辑公式，即用事先定义好的一些特定字符，及这些特定字符的组合，组成一个规则字符串，这个规则字符串用来表达对字符串的一种**过滤逻辑**

### 使用

规则：` / pattern /flags `     pattern为模式，flags为修饰符，修饰符用来表示正则的匹配模式

~~~js
// 使用直接字面量创建，性能更好 pattern不能为空，不然以为是注释
let exp1 = /\d/g
//使用RegExp创建
let exp2 = RegExp('\d','g')
~~~

#### 元字符

* 是拥有特殊含义的字符，包括 `( [ { \ ^ $ | ? * + . } ] )`
* 模式中使用前建议在之前加 \ 转义

#### 修饰符-匹配模式

| 修饰符  | 描述                                                 |
| :------ | :--------------------------------------------------- |
| i       | 执行对大小写不敏感的匹配                             |
| g       | 执行全局匹配，查找所有匹配而非在找到第一个匹配后停止 |
| m       | 执行多行匹配，会改变 `^`和 `$`的行为                 |
| u       | 可以匹配4字节的unicode编码， `.` 可以匹配Unicode字符 |
| s (ES9) | dotAll模式， `.`可以匹配换行符                       |

补充： `.` 一般情况下不能匹配 Unicode字符和换行符，只有在特定模式下才可以

#### 限定符

* `* + ? {n,m}`
*  一般的字符后面追加限定符是（尽可能多）的匹配匹配项，限定符后面追加问号的是（尽可能少）的匹配匹配项。 如：`*? +? ?? {n,m}?`

#### 类

* 使用`[ ]`来表达，用于查找某个范围内的字符；如：查数字 `[0-9]`

| 预定义类 | 等价              | 描述                                      |
| :------- | :---------------- | :---------------------------------------- |
| `\s`     | `[\t\n\x0B\f\r]`  | 空格                                      |
| `\S`     | `[^\t\n\x0B\f\r]` | 非空格                                    |
| `\d`     | `[0-9]`           | 数字                                      |
| `\D`     | `[^0-9]`          | 非数字                                    |
| `\w`     | `[a-zA-Z_0-9]`    | 单词字符 ( 字母、数字、下划线)            |
| `\W`     | `[^a-zA-Z_0-9]`   | 非单词字符                                |
| `.`      | `[^\r\n]`         | 任意字符，除了回车与换行外所有字符        |
| `\f`     | `\x0c` `\cL`      | 匹配一个换页符                            |
| `\n`     | `\x0a` `\cJ`      | 匹配一个换行符                            |
| `\r`     | `\x0d` `\cM`      | 匹配一个回车符                            |
| `\t`     | `\x09` `\cI`      | 匹配一个制表符                            |
| `\v`     | `\x0b` `\cK`      | 匹配一个垂直制表符                        |
| `\xxx`   |                   | 查找以八进制数 xxx 规定的字符             |
| `\xdd`   |                   | 查找以十六进制数 dd 规定的字符            |
| `\uxxxx` |                   | 查找以十六进制数 xxxx 规定的 Unicode 字符 |

#### 量词

表示匹配多少个目标对象，精确匹配长度使用 `{ }`

| 量词    | 等价    | 描述                    |
| :------ | :------ | :---------------------- |
| n `*`   | `{0,}`  | 匹配零个或多个n         |
| n `+`   | `{1,}`  | 匹配至少一个 n 的字符串 |
| n `?`   | `{0,1}` | 匹配零个或一个n         |
| `{n}`   |         | 匹配n次                 |
| `{n,m}` |         | 匹配n到m次              |
| `{n,}`  |         | 至少匹配n次             |

#### 边界

| 边界 | 描述                        |
| :--- | :-------------------------- |
| `^`  | 以xx开始，在类 `[]`中表示非 |
| `$`  | 以xx结束                    |
| `\b` | 单词边界                    |
| `\B` | 非单词边界                  |

`^`匹配字符串开始位置，也就是位置0，如果设置了 RegExp 对象的 Multiline 属性 `m`， `^` 也匹配 '\n' 或 '\r' 之后的位置

`$`一般匹配字符串结束位置，如果设置了 RegExp 对象的 Multiline 属性 `m`， `$` 也匹配 '\n' 或 '\r' 之前的位置

`\b`匹配一个单词边界，也就是指单词和空格间的位置，如 `er\b`可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er' 

`\B`匹配非单词边界。如 `er\B`能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'

#### 分组

 **分组**使用 `( )`，作用是提取相匹配的字符串，使量词作用于分组 比如 `hehe{3}`是把 `e`匹配了3次而不是单词，如果希望作用于单词，可以使用分组 `(hehe){3}` 

* 或： 分组中使用 `|` 可以达到**或**的效果； 如：`T(oo|ii)m`可以匹配 Toom 和 Tiim
* 反向引用： 使用 `()`后可以使用 `$1`- `$9`等来匹配；如：` '2018-02-11'.replace(/(\d{4})\-(\d{2})\-(\d{2})/g, '$2/$3/$1')  `
* 后向引用： `\n` 表示后向引用， `\1`是指在正则表达式中，从左往右数第1个 `()`中的内容；以此类推， `\2`表示第2个 `()`， `\0`表示整个表达式。 
*  后向引用和反向引用的区别是：`\n`只能用在表达式中，而 `$n`只能用在表达式之外的地方。 
* 分组命名（ES9）
  * 命名正则：`let reDate = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/; `
  * 结合反向引用：`let day = str.replace(reDate,'$<month>-$<day>-$<year>'); `
* 忽略分组：在分组内加上 `?:`即可，如：`(?:to).(ok)`这里的 $1 就是指ok

##### 前瞻- 向后检查 

| 名称     | 正则    | 描述         |
| :------- | :------ | :----------- |
| 正向前瞻 | `(?= )` | 后面要有xx   |
| 负向前瞻 | `(?! )` | 后面不能有xx |

##### 后顾(ES9)- 向后检查 

| 名称     | 正则     | 描述         |
| :------- | :------- | :----------- |
| 正向后顾 | `(?<= )` | 前面要有xx   |
| 负向后顾 | `(?<! )` | 前面不能有xx |

#### 贪婪模式

正则在匹配时默认尽可能多的匹配，叫贪婪模式。如： `\d{3,6}`默认会匹配6个数字而不是3个 

**非贪婪模式**：在限定符后加 `?` 如：`\d{3,6}?`， 匹配3次 

#### 优先级

从高到低

* 转义 `\`
* 括号 `()`、`(?: )`、`(?= )`、`[]`
* 字符和位置
* 或 `|`

### 常用属性和方法

#### RegExp 对象属性

**RegExp构造函数属性**

语法：`RegExp.$_`或 `RegExp.["$&"]`

| 长属性名     | 短属性名 | 描述                                                         |
| :----------- | :------- | :----------------------------------------------------------- |
| input        | `$_`     | 返回执行规范表述查找的字符串。只读                           |
| lastMatch    | `$&`     | 返回任何正则表达式搜索过程中的最后匹配的字符。只读           |
| lastParen    | `$+`     | 如果有的话，返回任何正则表达式查找过程中最后括的子(分组)匹配。只读 |
| leftContext  | `$\`     | 返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符。只读 |
| rightContext | `$'`     | 返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。只读 |

**RegExp实例上的属性**

语法：` pattern.global `

| 属性       | 描述                                               |
| :--------- | :------------------------------------------------- |
| global     | 是否全文搜索，默认 `false`，对应修饰符的 `g`，只读 |
| ignoreCase | 是否大小写敏感，默认 `false`，对应修饰符 `i`，只读 |
| multiline  | 是否多行搜索，默认 `false`，对应修饰符 `m`，只读   |
| flags      | 返回修饰符，只读                                   |
| lastIndex  | 当前表达式匹配内容的最后一个字符的下一个位置       |
| source     | 正则表达式的文本字符串                             |

#### 常用方法

* 检索字符串中的正则匹配 ：pattern表示正则，如：`let pattern=/.at/g;`
  * `str.match(pattern) `；成功则返回数组，失败返回null
  * `pattern.exec(str)`；成功则返回数组，失败返回null
  * **异同**：在非全局模式下，两种方法返回结果相同；全局模式下match会一下返回所有匹配项，而exec每一次只返回一项 ，下次调用接着向后匹配。 
* 检测是否存在正则匹配项：`pattern.test(str)`；并返回布尔值
* 检索是否存在正则匹配项：`str.search(pattern)`；存在返回第一个匹配结果的索引，不存在则返回 -1
* 分割字符串成数组：`str.split(pattern|str)`；返回数组
* 找到匹配并替换：`str.replace(reg,str|num|function)`；返回新的字符串

### 常用正则

~~~js
// 真实姓名
/*
1.可以是中文
2.可以是英文，允许输入点（英文名字中的那种点）， 允许输入空格
3.中文和英文不能同时出现
4.长度在20个字符以内
*/
let pattern = /^([\u4e00-\u9fa5]{1,20}|[a-zA-Z\.\s]{1,20})$/

pattern.test(value)
~~~

### 使用注意

1. 不要使用静态方法，而一定要显式的声明Regex对象

> 原因是静态方法会临时创建一个Regex对象，用它来调用请求的方法，然后弃用这个对象。而静态方法每次调用，都必须重新检查正则表达式，所以存在效率缺陷 

2. 不要在循环体中声明Regex对象 
3. 通常情况下，` <.+?>`是没有` <[^>]*>`的效率高的 
4. 匹配失败不需要回溯的子表达式，用固化分组`(?>…)`加速失败过程，同时避免回溯 
   那么` <[^>]*>`通常还可以通过固化分组的方式进行优化` <(?>[^>]*)> `